What is the relationship between Node.js and V8? Can Node work without V8?
- NodeJS is basically C++ application 
- It uses V8 engine to execute JavaScript code. 
- V8 engine compiles JavaScript directly into machine code before executing it. 
- There are several other modules within NodeJS to perform different functions. 
- Without V8 engine, NodeJS won’t work at all 
    but NodeJS can use different JavaScript engine such as Mozilla’s Gecko engine instead of using chrome’s V8 engine.

-----------------------------------------------------------------------------------------------------
How come when you declare a global variable in any Node.js file it’s not really global to all modules?
- We can declare global variables in NodeJS by using ‘global’ or ‘GLOBAL’ keyword
    (or) declare variable without ‘var’ keyword. 
- preferred is global... not GLOBAL
-----------------------------------------------------------------------------------------------------
exports_vs_module.exports
- If we want to add properties which should be public within greetings.js 
    we can simply create exports variable as above 
    and add properties directly on it 
- example
    exports.sayHelloInEnglish = function() { console.log(“Hello”) }
    https://www.sitepoint.com/understanding-module-exports-exports-node-js/

-----------------------------------------------------------------------------------------------------
require local files without using relative paths?

(A) create global variable 
    global.__baseDir = __dirname + ‘/’;             // inside app.js file 
    require(global.__baseDir+’/model/…’)            // use this


(B) People sometimes object to putting application-specific modules into node_modules 
    because it is not obvious how to check in your internal modules 
    without also checking in third-party modules from npm.

    inside .gitignore
        instead of this
            node_modules    
        use this
            node_modules/*
            !node_modules/foo
            !node_modules/bar

    you can’t unignore a subdirectory, if the parent is already ignored. 
    So instead of ignoring node_modules, you have to ignore every directory inside node_modules 
        with the node_modules/*

    Now anywhere in your application you will be able to require('foo') or require('bar') 
    without having a very large and fragile relative path.
-----------------------------------------------------------------------------------------------------
Can different versions of the same package be used in the same application?
- Unless the changes in the packages won’t break the application, 
    we can use different versions of the same package in the same application.
---------------------------------------------------------------------------------------------------------

What is the Event Loop? Is it part of V8?
- Event loop is actually an observer of event message queue.
- Whenever any kind of event is registered in an event message queue
    event loop processes it 
    and runs a callback (event handler). 
- Event Loop is not a part of V8 engine. 
- Under the hood NodeJS operates various operations asynchronously 
    even though V8 engine it self executes synchronously.
- Event loop in NodeJS is handled by LIBUV library written in C.
- All below 3 operate asynchronously.
    V8’s executions,
    operating system operations (eg. read/write files, connect to database etc) 
    event loop
- Read this         https://nodesource.com/blog/understanding-the-nodejs-event-loop/

---------------------------------------------------------------------------------------------------------
What is the Call Stack? Is it part of V8?

JavaScript is single-threaded, meaning it has a single call stack, meaning it can do one thing at a time. The call stack is basically a data structure which records where in the program we are. If we step into a function, we push something onto the stack. If we return from a function, we pop off the top of the stack.

When our program throws an error, we see the call stack in the console. We see the state of the stack (which functions have been called) when that error happened.

Call Stack is a part of V8 engine. V8 uses heap for memory allocation and call stack to execute the code. Call stack is also called as execution stack.



8. What is the difference between setImmediate and process.nextTick?

setImmediate() is designed to execute a script once the current poll phase in an event loop phase completes.

Any time you call process.nextTick() in a given phase, all callbacks passed to process.nextTick() will be resolved before the event loop continues. This can create some bad situations because it allows you to “starve” your I/O by making recursive process.nextTick() calls, which prevents the event loop from reaching the poll phase. For Eg.

function apiCall (arg, callback) {
if (typeof arg !== ‘string’)
return process.nextTick(callback,
new TypeError(‘argument should be string’));
}

What we’re doing is passing an error back to the user but only after we have allowed the rest of the user’s code to execute. By using process.nextTick() we guarantee that apiCall() always runs its callback after the rest of the user’s code and before the event loop is allowed to proceed.

For details please refer this link https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/

9. How do you make an asynchronous function return a value?

We can use callback or promises to return a value from an asynchronous function.

10. Can callbacks be used with promises or is it one way or the other?

Promises internally uses callbacks. And yes, we can use callbacks with promises as well. A callback is a function that is passed into a function with the purpose of being called by that function.




What Node module is implemented by most other Node modules?

This is just an example of a single module called ‘events’ which is implemented by other modules in NodeJS. For eg. EventEmitter of events module is used by ReadableStreams, WriteablStreams and so on.

Commonly used NodeJS modules are events, buffer, util, stream. You can find several common modules used by other modules form nodejs github repository.
Generally NodeJS provides following builtin modules which is used to create other node modules. exports.builtinLibs = [

‘assert’, ‘buffer’, ‘child_process’, ‘cluster’, ‘crypto’, ‘dgram’, ‘dns’,

‘domain’, ‘events’, ‘fs’, ‘http’, ‘https’, ‘net’, ‘os’, ‘path’, ‘punycode’,

‘querystring’, ‘readline’, ‘repl’, ‘stream’, ‘string_decoder’, ‘tls’, ‘tty’,

‘url’, ‘util’, ‘v8’, ‘vm’, ‘zlib’

];



12. What are the major differences between spawn, exec, and fork?

We can create a child process using require (‘child_process’).spawn() or require(‘child_process’).fork() or require(‘child_process’).exec().

Spawn is a command designed to run system commands. When you run spawn, you send it a system command that will be run on its own process, but does not execute any further code within your node process. You can add listeners for the process you have spawned, to allow your code interact with the spawned process, but no new V8 instance is created(unless of course your command is another Node command, but in this case you should use fork!) and only one copy of your node module is active on the processor.

Fork is a special instance of spawn, that runs a fresh instance of the V8 engine. Meaning, you can essentially create multiple workers, running on the exact same Node code base, or perhaps a different module for a specific task. This is most useful for creating a worker pool. While nodes async event model allows a single core of a machine to be used fairly efficiently, it doesn’t allow a node process to make use of multi core machines. Easiest way to accomplish this is to run multiple copies of the same program, on a single processor.

The most significant difference between child_process.spawn and child_process.exec is in what they return — spawn returns a stream and exec returns a buffer.

child_process.exec returns the whole buffer output from the child process. By default the buffer size is set at 200k. If the child process returns anything more than that, you program will crash with the error message “Error: maxBuffer exceeded”. You can fix that problem by setting a bigger buffer size in the exec options. But you should not do it because exec is not meant for processes that return HUGE buffers to Node. You should use spawn for that. So what do you use exec for? Use it to run programs that return result statuses, instead of data.

child_process.exec is “synchronously asynchronous”, meaning although the exec is asynchronous, it waits for the child process to end and tries to return all the buffered data at once. If the buffer size of exec is not set big enough, it fails with a “maxBuffer exceeded” error.

-------------------------------------------------------------------------------------


13. How does the cluster module work? How is it different than using a load balancer?

A single instance of Node.js runs in a single thread. To take advantage of multi-core systems the user will sometimes want to launch a cluster of Node.js processes to handle the load.The cluster module allows you to easily create child processes that all share server ports.The worker processes are spawned using the child_process.fork() method, so that they can communicate with the parent via IPC and pass server handles back and forth.The cluster module supports two methods of distributing incoming connections.

The first one (and the default one on all platforms except Windows), is the round-robin approach, where the master process listens on a port, accepts new connections and distributes them across the workers in a round-robin fashion, with some built-in smarts to avoid overloading a worker process.

The second approach is where the master process creates the listen socket and sends it to interested workers. The workers then accept incoming connections directly.

Not sure: How cluster is different than using a load balancer?: I think node js cluster module allows back and forth Inter Process Communication(IPC) between master and child processes but using load balancers like Nginx does not provide this flexibility.

14. What are the --harmony-* flags?

harmony flags are used to enable staged features which are almost-completed features that are not considered stable by the V8 team.

All ECMAScript 2015 (ES6) features are split into three groups for shipping, staged, and in progress features:

All shipping features, which V8 considers stable, are turned on by default on Node.js and do NOT require any kind of runtime flag.
Staged features, which are almost-completed features that are not considered stable by the V8 team, require a runtime flag: --harmony.
In progress features can be activated individually by their respective harmony flag, although this is highly discouraged unless for testing purposes. Note: these flags are exposed by V8 and will potentially change without any deprecation notice.



15. How can you read and inspect the memory usage of a Node.js process?

In node JS we can use process.memoryUsage() method which returns an object describing the memory usage of the Node.js process measured in bytes. Eg.{
rss: 4935680,
heapTotal: 1826816,
heapUsed: 650472,
external: 49879
}

Resident set(rss), heapTotal and heapUsed refer to V8's memory usage. external refers to the memory usage of C++ objects bound to JavaScript objects managed by V8. Diagram below shows how memory allocation takes place in V8 engine.

V8’s Memory Scheme
A running program is always represented through some space allocated in memory. This space is called Resident Set. V8 uses a scheme similar the Java Virtual Machine and divides the memory into segments:

Code: the actual code being executed
Stack: contains all value types (primitives like integer or Boolean) with pointers referencing objects on the heap and pointers defining the control flow of the program
Heap: a memory segment dedicated to storing reference types like objects, strings and closures.


https://medium.com/@jitubutwal144/before-you-bury-yourself-in-packages-learn-the-node-js-runtime-itself-answers-part3-45f9fd8219a7